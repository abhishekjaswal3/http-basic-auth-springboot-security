package com.abhi.security.utility;


import java.nio.file.*;
import java.security.*;

import java.security.spec.*;
import java.util.Base64;

/*
import java.security.interfaces.RSAPrivateKey;
import org.bouncycastle.asn1.pkcs.*;
import org.bouncycastle.asn1.x509.*;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;
import java.io.*;
*/
/**
 * Commands to generate private and public pem file
 * 1) private - openssl genrsa -out private.pem 2048
 *
 * the file generated using openssl genrsa is in the (PKCS is Public-Key Cryptography Standards.)
 * PKCS#1 format,
 * which is not the default format expected by Java's PKCS8EncodedKeySpec
 *
 * so use command
 *
 * openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in private.pem -out private_pkcs8.pem
 *
 * openssl pkcs8: The OpenSSL utility for PKCS#8 key format.
 *
 * -topk8: This flag tells OpenSSL to convert the input key to the PKCS#8 format.
 *
 * -inform PEM: Specifies the input format is PEM.
 *
 * -outform PEM: Specifies the output format should also be PEM.
 *
 * -nocrypt: This is crucial. It ensures the output key is not encrypted with a password, which simplifies its use in your application.
 *
 * -in private.pem: The input file name.
 *
 * -out private_pkcs8.pem: The output file name.
 *
 *
 *2) public - openssl rsa -in private.pem -pubout -out public.pem
 *PEM -PRIVACY ENHANCED MAIL
 *
 *  there is no change needed for the public.pem file.
 *
 * The public.pem file generated by openssl rsa -in private.pem -pubout
 * is already in the correct X.509 format, which is the standard format for public keys.
 * This format begins with -----BEGIN PUBLIC KEY----- and is directly compatible
 * with Java's X509EncodedKeySpec
 */
public final class PemUtils {

    private PemUtils() {}

   // JWT libraries expect standard PrivateKey/PublicKey objects, not raw PEM strings
    public static PrivateKey readPrivateKey(Path pemPath) throws Exception {
        String pem = Files.readString(Paths.get("src/main/resources/keys/private_pkcs8.pem"));
        if (pem.contains("-----BEGIN PRIVATE KEY-----")) {
            // PKCS#8
            byte[] der = parseDerFromPem(pem, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----");
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(der);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return kf.generatePrivate(spec);
        } /*else if (pem.contains("-----BEGIN RSA PRIVATE KEY-----")) {
            // PKCS#1 -> convert to PKCS#8
            try (PemReader pr = new PemReader(Files.newBufferedReader(pemPath))) {
                PemObject obj = pr.readPemObject();
                byte[] content = obj.getContent(); // PKCS#1 bytes
                // Wrap into PKCS#8
                RSAPrivateKey rsaPriv = RSAPrivateKey.getInstance(ASN1Sequence.fromByteArray(content));
                PrivateKeyInfo pkInfo = new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, null),
                        rsaPriv);
                byte[] pkcs8Bytes = pkInfo.getEncoded();
                PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(pkcs8Bytes);
                KeyFactory kf = KeyFactory.getInstance("RSA");
                return kf.generatePrivate(spec);
            }
        } */else {
            throw new IllegalArgumentException("Unsupported private key format");
        }
    }

    public static PublicKey readPublicKey(Path pemPath) throws Exception {
        String pem = Files.readString(Paths.get("src/main/resources/keys/public.pem"));
        if (pem.contains("-----BEGIN PUBLIC KEY-----")) {
            byte[] der = parseDerFromPem(pem, "-----BEGIN PUBLIC KEY-----", "-----END PUBLIC KEY-----");
            X509EncodedKeySpec spec = new X509EncodedKeySpec(der);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return kf.generatePublic(spec);
        } /*else if (pem.contains("-----BEGIN RSA PUBLIC KEY-----")) {
            // Some public keys are in PKCS#1 form; convert to X509
            try (PemReader pr = new PemReader(Files.newBufferedReader(pemPath))) {
                PemObject obj = pr.readPemObject();
                byte[] content = obj.getContent(); // PKCS#1 RSAPublicKey
                org.bouncycastle.asn1.pkcs.RSAPublicKey rsaPub = org.bouncycastle.asn1.pkcs.RSAPublicKey.getInstance(ASN1Sequence.fromByteArray(content));
                SubjectPublicKeyInfo spki = new SubjectPublicKeyInfo(
                        new AlgorithmIdentifier(org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers.rsaEncryption, org.bouncycastle.asn1.DERNull.INSTANCE),
                        rsaPub);
                byte[] x509Bytes = spki.getEncoded();
                X509EncodedKeySpec spec = new X509EncodedKeySpec(x509Bytes);
                KeyFactory kf = KeyFactory.getInstance("RSA");
                return kf.generatePublic(spec);
            }
        }*/ else {
            throw new IllegalArgumentException("Unsupported public key format");
        }
    }

    private static byte[] parseDerFromPem(String pem, String beginMarker, String endMarker) {
        int start = pem.indexOf(beginMarker);
        int end = pem.indexOf(endMarker);
        if (start < 0 || end < 0) throw new IllegalArgumentException("PEM markers not found");
        String base64 = pem.substring(start + beginMarker.length(), end).replaceAll("\\s", "");
        return Base64.getDecoder().decode(base64);
    }
}

